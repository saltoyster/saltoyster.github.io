<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="title:多线程知识点多线程volatile关键字Java的内存模型(JMM) 主内存：主内存被所有的线程共享，对于一个共享变量，主内存中存储的就是它“本尊” 工作内存：每个线程都有自己的工作内存，对于共享变量来说，工作内存中存储的就是它的“副本” volatile特性1.保证变量在线程之间的可见性。 2.阻止编译和运行时的指令重排。 volatile关键字在双重锁实现单例作用单例模式在单线程">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2021/07/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="title:多线程知识点多线程volatile关键字Java的内存模型(JMM) 主内存：主内存被所有的线程共享，对于一个共享变量，主内存中存储的就是它“本尊” 工作内存：每个线程都有自己的工作内存，对于共享变量来说，工作内存中存储的就是它的“副本” volatile特性1.保证变量在线程之间的可见性。 2.阻止编译和运行时的指令重排。 volatile关键字在双重锁实现单例作用单例模式在单线程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5Cv2-4798842c9e3443c8e785861e417041e9_720w.jpg">
<meta property="og:image" content="http://example.com/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5CCAS1.webp">
<meta property="og:image" content="http://example.com/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5CCAS2.webp">
<meta property="og:image" content="http://example.com/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5CCAS3.webp">
<meta property="og:image" content="http://example.com/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5CCAS4.webp">
<meta property="og:image" content="http://example.com/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5CCAS5.webp">
<meta property="og:image" content="http://example.com/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5CCAS6.webp">
<meta property="og:image" content="http://example.com/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5CCAS7.webp">
<meta property="og:image" content="http://example.com/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5CAQS.png">
<meta property="og:image" content="http://example.com/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5C%E7%BA%BF%E7%A8%8B%E6%B1%A0.jpg">
<meta property="og:image" content="http://example.com/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%B5%81%E7%A8%8B.webp">
<meta property="article:published_time" content="2021-07-26T13:23:18.624Z">
<meta property="article:modified_time" content="2021-08-16T17:08:36.776Z">
<meta property="article:author" content="Zyh">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5Cv2-4798842c9e3443c8e785861e417041e9_720w.jpg">

<link rel="canonical" href="http://example.com/2021/07/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-26 21:23:18" itemprop="dateCreated datePublished" datetime="2021-07-26T21:23:18+08:00">2021-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-17 01:08:36" itemprop="dateModified" datetime="2021-08-17T01:08:36+08:00">2021-08-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<h2 id="title-多线程知识点"><a href="#title-多线程知识点" class="headerlink" title="title:多线程知识点"></a>title:多线程知识点</h2><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><h4 id="Java的内存模型-JMM"><a href="#Java的内存模型-JMM" class="headerlink" title="Java的内存模型(JMM)"></a>Java的内存模型(JMM)</h4><p><img src="/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5Cv2-4798842c9e3443c8e785861e417041e9_720w.jpg" alt="v2-4798842c9e3443c8e785861e417041e9_720w"></p>
<p><strong>主内存：</strong>主内存被所有的线程共享，对于一个共享变量，主内存中存储的就是它“本尊”</p>
<p><strong>工作内存：</strong>每个线程都有自己的工作内存，对于共享变量来说，工作内存中存储的就是它的“副本”</p>
<h4 id="volatile特性"><a href="#volatile特性" class="headerlink" title="volatile特性"></a>volatile特性</h4><p>1.保证变量在线程之间的可见性。</p>
<p>2.阻止编译和运行时的指令重排。</p>
<h3 id="volatile关键字在双重锁实现单例作用"><a href="#volatile关键字在双重锁实现单例作用" class="headerlink" title="volatile关键字在双重锁实现单例作用"></a>volatile关键字在双重锁实现单例作用</h3><p>单例模式在单线程下一般分为懒汉模式，和饿汉模式，总体来说，懒汉模式的优点可以突出的显现；但是当变成多线程时，饿汉模式可以很好的避免安全隐患，而懒汉模式则不可以。</p>
<h4 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1.饿汉式"></a>1.饿汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2.懒汉式"></a>2.懒汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">   　　 <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-为什么是双重校验锁实现单例模式呢"><a href="#3-为什么是双重校验锁实现单例模式呢" class="headerlink" title="3.为什么是双重校验锁实现单例模式呢"></a>3.为什么是双重校验锁实现单例模式呢</h4><p>是一个<strong>重点知识</strong>敲黑板，<strong>第一层为了提高效率</strong>，思想：优化思想，提升执行效率（速度和开销），<strong>第二次</strong>实际上才是真正的实现单例模式，实际上变成普通的一个<strong>懒汉模式+synchronzied关键字</strong>，多了一个同步锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  &#125;;<span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123; <span class="comment">//目的：提高效率</span></span><br><span class="line">        <span class="comment">//刚开始所有进入这行代码的线程，uniqueInstance对象都是null</span></span><br><span class="line">        <span class="comment">//可能是第一个进去的线程，这时候uniqueInstance对象都是null</span></span><br><span class="line">        <span class="comment">//也可能是第一个线程之后的线程进入并执行</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123; </span><br><span class="line">               <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123; </span><br><span class="line">                   uniqueInstance = <span class="keyword">new</span> Singleton();    </span><br><span class="line">            &#125;           </span><br><span class="line">       &#125;       </span><br><span class="line">   &#125;        </span><br><span class="line">     <span class="keyword">return</span> uniqueInstance;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized时Java中的关键字，是一种同步锁。Java中每一个对象都可以作为锁，这是synchronized实现同步的基础。</p>
<ol>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； </li>
</ol>
<p>　　2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；<br>　　3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；<br>　　4. 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</p>
<h3 id="sleep-和wait-的区别"><a href="#sleep-和wait-的区别" class="headerlink" title="sleep()和wait()的区别"></a>sleep()和wait()的区别</h3><h4 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h4><p>sleep()方法是Thread类的方法，线程通过调用该方法，进入休眠状态主动让出CPU，从而CPU可以执行其他线程。经过sleep指定的时间后，CPU回到这个线程上继续往下执行。</p>
<p>当前线程进入了同步锁，sleep()方法并不会释放锁。即使当前线程使用sleep()方法让出了cpu，但其他被同步锁挡住的线程也无法得到执行。</p>
<p><strong>使用场合</strong></p>
<p>线程的调度执行是按照其优先级的高低顺序进行的，当高级别的线程未死亡时，低级别的线程没有机会获得CPU资源。有时优先级高的线程需要优先级低的线程完成一些辅助工作或者优先级高的线程需要完成一些比较费时的工作，此时优先级高的线程应该让出CPU资源，使得优先级低的线程有机会执行。为了达到这个目的，优先级高的线程可以在自己的run()方法中调用sleep方法来使自己放弃CPU资源，休眠一段时间。</p>
<p><strong>注意</strong></p>
<p>如果线程在休眠时被打断，JVM就会抛出InterruptedException异常。因此，必须在try-catch语句块中调用sleep方法。</p>
<h4 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait()方法"></a>wait()方法</h4><p>wait()方法可以中断线程的运行，使本线程等待，暂时让出CPU的使用权，允许其他线程使用这个同步方法。其他线程如果在使用这个同步方法时不需要等待，那么它使用完这个方法的同时，应该用notifyAll()方法通知所有由于使用了这个同步方法而处于等待的线程结束等待，曾中断的线程就会从刚才中断处继续执行这个同步方法（并不是立马执行，而是结束等待），并遵循“先中断先继续”的原则。</p>
<p>wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在notfiy方法后增加一个等待和一些代码，看看效果）<br><strong>使用场合</strong></p>
<p>当一个线程使用的同步方法中用到某个变量，而此变量又需要起亚线程修改后才能符合本线程的需要，那么可以在同步方法中使用wait()方法。</p>
<p><strong>注意</strong></p>
<p>wait()、notify()和notifyAll()都是Object类的final方法，被所有的类继承且不允许重写的方法。特别需要注意的是，不可以在非同步方法中使用上述三个方法。（从功能和使用场合也可以看出）</p>
<h3 id="ReentrantLock-重入锁"><a href="#ReentrantLock-重入锁" class="headerlink" title="ReentrantLock(重入锁)"></a>ReentrantLock(重入锁)</h3><p>jdk中独占锁的实现除了使用关键字synchronized外,还可以使用ReentrantLock。虽然在性能上ReentrantLock和synchronized没有什么区别，但ReentrantLock相比synchronized而言功能更加丰富，使用起来更为灵活，也更适合复杂的并发场景。</p>
<h4 id="ReentranLock和Sychroniezd的相同点"><a href="#ReentranLock和Sychroniezd的相同点" class="headerlink" title="ReentranLock和Sychroniezd的相同点"></a>ReentranLock和Sychroniezd的相同点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码通过lock()方法获取锁三次，然后通过unlock()方法释放锁三次，程序可以正常退出。可看出ReentrantLock是可以重入的锁，当一个线程获取锁时，还可以接着重复获取多次。</p>
<ul>
<li>1.ReentrantLock和synchronized都是独占锁,只允许线程互斥的访问临界区。但是实现上两者不同:synchronized加锁解锁的过程是隐式的,用户不用手动操作,优点是操作简单，但显得不够灵活。一般并发场景使用synchronized的就够了；ReentrantLock需要手动加锁和解锁,且解锁的操作尽量要放在finally代码块中,保证线程正确释放锁。ReentrantLock操作较为复杂，但是因为可以手动控制加锁和解锁过程,在复杂的并发场景中能派上用场。</li>
<li>2.ReentrantLock和synchronized都是可重入的。synchronized因为可重入因此可以放在被递归执行的方法上,且不用担心线程最后能否正确释放锁；而ReentrantLock在重入时要却确保重复获取锁的次数必须和重复释放锁的次数一样，否则可能导致其他线程无法获得该锁。</li>
</ul>
<h4 id="ReentrantLock的额外功能"><a href="#ReentrantLock的额外功能" class="headerlink" title="ReentrantLock的额外功能"></a>ReentrantLock的额外功能</h4><ol>
<li>ReentrantLock可以实现公平锁</li>
<li>ReentrantLock可以响应中断</li>
<li>ReentrantLock可以获取锁现时等待</li>
<li>可以配合Condition实现等待通知机制</li>
</ol>
<h3 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock(读写锁)"></a>ReadWriteLock(读写锁)</h3><p>ReadWriteLock管理一组锁，一个是只读的锁，一个是写锁。读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的。</p>
<p>所有读写锁的实现必须确保读操作对读操作的内存影响。换句话说，一个锁获得了读锁的线程必须能看到前一个释放的写锁所更新的内容。</p>
<p>读写锁比互斥锁允许对于共享数据更大程度的并发。每次只能有一个写线程，但是同时可以有多个线程并发地读取数据。ReadWriteLock适用于读多写少的并发情况。</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>ReentrantReadWriteLock有如下特性：</p>
<ul>
<li><p>获取顺序</p>
<ul>
<li><p>非公平模式（默认）<br>当以非公平初始化时，读锁和写锁的获取的顺序是不确定的。非公平锁主张竞争获取，可能会延缓一个或多个读或写线程，但是会比公平锁有更高的吞吐量。</p>
</li>
<li><p>公平模式<br>当以公平模式初始化时，线程将会以队列的顺序获取锁。当当前线程释放锁后，等待时间最长的写锁线程就会被分配写锁；或者有一组读线程组等待时间比写线程长，那么这组读线程组将会被分配读锁。<br>当有写线程持有写锁或者有等待的写线程时，一个尝试获取公平的读锁（非重入）的线程就会阻塞。这个线程直到等待时间最长的写锁获得锁后并释放掉锁后才能获取到读锁。</p>
</li>
</ul>
</li>
<li><p>可重入<br>  允许读锁可写锁可重入。写锁可以获得读锁，读锁不能获得写锁。</p>
</li>
<li><p>锁降级<br>  允许写锁降低为读锁</p>
</li>
<li><p>中断锁的获取<br>  在读锁和写锁的获取过程中支持中断</p>
</li>
<li><p>支持Condition<br>  写锁提供Condition实现</p>
</li>
<li><p>监控<br>  提供确定锁是否被持有等辅助方法</p>
</li>
</ul>
<h3 id="CAS机制"><a href="#CAS机制" class="headerlink" title="CAS机制"></a>CAS机制</h3><p>CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。</p>
<p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</p>
<p>1.在内存地址V当中，存储着值为10的变量。</p>
<p><img src="/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5CCAS1.webp" alt="CAS1"></p>
<p>2.此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。</p>
<p><img src="/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5CCAS2.webp" alt="CAS2"></p>
<p>3.在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。</p>
<p><img src="/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5CCAS3.webp" alt="CAS3"></p>
<p>4.线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。</p>
<p><img src="/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5CCAS4.webp" alt="CAS4"></p>
<p>5.线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋。</p>
<p><img src="/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5CCAS5.webp" alt="CAS5"></p>
<p>6.这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。</p>
<p><img src="/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5CCAS6.webp" alt="CAS6"></p>
<p>7.线程1进行SWAP，把地址V的值替换为B，也就是12。</p>
<p><img src="/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5CCAS7.webp" alt="CAS7"></p>
<h4 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h4><p>1.CPU开销较大<br> 在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</p>
<p>2.不能保证代码块的原子性<br> CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。</p>
<h3 id="synchronize的优化"><a href="#synchronize的优化" class="headerlink" title="synchronize的优化"></a>synchronize的优化</h3><h4 id="自旋锁（自适应锁）"><a href="#自旋锁（自适应锁）" class="headerlink" title="自旋锁（自适应锁）"></a>自旋锁（自适应锁）</h4><p>由于线程阻塞进入排队队列和唤醒都需要CPU从用户态转为核心态，花费时间较多，频繁的阻塞和唤醒对CPU来说也是负荷很重的工作，同时，统计发现很多线程锁定状态都持续很短时间，如果这时候其他线程等待队列后再唤醒的代价比较大，所以出现了自旋锁。</p>
<p><strong>自旋锁</strong>，由于线程阻塞和唤醒的代价比较大，对于等待的线程，不先加到等待队列中，而是去执行一个无意义的循环，一直到运行的线程结束之后去竞争锁。但是明显自旋锁使得synchronized的对象锁方式在线程之间引入了不公平，而且CPU在等待自旋锁时不做任何有用的工作，仅仅是等待，浪费资源，但是这样可以保证大吞吐率和执行效率。但是由于CPU的自旋消耗比较大，因此自旋是有范围的，超过这个范围就会进入排队队列，即重量级锁的机制<br><strong>自适应自旋锁</strong>，就是自旋的次数是通过JVM在运行时收集的统计信息，动态调整自旋锁的自旋次数上界。</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>如果JVM明显检测到某段代码是<strong>线程安全</strong>的（无锁也是安全的），JVM会安全地将原有的锁除掉。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vectorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">            vector.add(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(vector);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Vector是默认加锁的，但JVM如果发现Vector变量仅仅在vectorTest()方法中使用，那vector是线程安全的。JVM会把vector内部加的锁去除，这个优化就叫做：锁消除。</p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>内置锁在Java中被抽象为监视器锁（monitor）。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁能提升程序同步性能的依据是对于绝大部分锁，在整个同步期间内都是不存在竞争的，这是一个经验数据。</p>
<ul>
<li>如果没有竞争，轻量级锁使用CAS操作避免了使用互斥的开销</li>
<li>但如果存在锁竞争，除了互斥量的开销外，还额外发生的CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。</li>
</ul>
<p>简单来说：如果发现同步期间都是不存在竞争，JVM会使用CAS操作来代替操作系统互斥量。这种优化被称为轻量级锁。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁就是在无竞争的情况下将整个同步锁都消除掉，连CAS操作都不做。</p>
<p>偏向锁可以提高带有同步但无竞争的程序性能。它同样是一个带有效益权衡（Trade Off）性质的优化，也就是说，他并不一定总是对程序运行有利，如果程序中大多数锁总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数<code>-XX：-UseBiasedLocking</code>来禁止偏向锁优化反而可以提升性能。</p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch…。</p>
<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p><img src="/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5CAQS.png" alt="AQS"></p>
<p>它维护了一个volatile int state(代表共享资源)和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。state的访问方式有三种：</p>
<ul>
<li>getstate()</li>
<li>setState()</li>
<li>compareAndSetState()</li>
</ul>
<p>AQS定义了两种资源共享方式：Exclusive(独占，只有一个线程能执行，如ReentrantLock)和Share(共享，)</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势"></a>线程池的优势</h4><ol>
<li>降低资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗。</li>
<li>提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行。</li>
<li>方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。</li>
<li>提供更强大的功能，演示定时线程池。</li>
</ol>
<h4 id="线程池的创建与参数"><a href="#线程池的创建与参数" class="headerlink" title="线程池的创建与参数"></a>线程池的创建与参数</h4><p>Java中提供了创建线程池的一个类：Executor</p>
<p>而我们创建时，一般使用它的子类：ThreadPoolExecutor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,  </span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,  </span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,  </span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,  </span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,  </span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory,  </span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<p>这是其中最重要的一个构造方法，这个方法决定了创建出来的线程池的各种属性：</p>
<p><img src="/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5C%E7%BA%BF%E7%A8%8B%E6%B1%A0.jpg" alt="线程池"></p>
<ol>
<li><p>corePoolSize（线程池基本大小）：当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，（除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。）</p>
</li>
<li><p>maximumPoolSize（线程池最大大小）：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。</p>
</li>
<li><p>keepAliveTime（线程存活保持时间）当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</p>
</li>
<li><p>workQueue（任务队列）：用于传输和保存等待执行任务的阻塞队列。</p>
</li>
<li><p>threadFactory（线程工厂）：用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。</p>
</li>
<li><p>handler（线程饱和策略）：当线程池和队列都满了，再加入线程会执行此策略。</p>
</li>
<li><p>util计算时间的单位</p>
</li>
</ol>
<h4 id="线程池的流程"><a href="#线程池的流程" class="headerlink" title="线程池的流程"></a>线程池的流程</h4><p><img src="/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B%5C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%B5%81%E7%A8%8B.webp" alt="线程池流程"></p>
<ol>
<li><p> 判断核心线程池是否已满，没满则创建一个新的工作线程来执行任务。已满则。</p>
</li>
<li><p>判断任务队列是否已满，没满则将新提交的任务添加在工作队列，已满则。</p>
</li>
<li><p>判断整个线程池是否已满，没满则创建一个新的工作线程来执行任务，已满则执行饱和策略。(调用handler实现拒接策略)</p>
</li>
</ol>
<p>handler的拒绝策略：</p>
<ol>
<li>AbortPolicy:不执行新任务，直接抛出异常，提示线程已满</li>
<li>DisCardPolicy：不执行新任务，也不抛出异常</li>
<li>DisCardOldSetPolicy:将消息队列中的第一个任务替换为当前新进来的任务执行</li>
<li>CallerRunsPolicy:直接调用execute来执行当前任务</li>
</ol>
<h4 id="四种常见线程池"><a href="#四种常见线程池" class="headerlink" title="四种常见线程池"></a>四种常见线程池</h4><p>CachedThreadPool:可缓存的线程池，该线程池中没有核心线程，非核心线程的数量为Integer.max_value，就是无限大，当有需要时创建线程来执行任务，没有需要时回收线程，适用于耗时少，任务量大的情况。</p>
<p>SecudleThreadPool:周期性执行任务的线程池，按照某种特定的计划执行线程中的任务，有核心线程，但也有非核心线程，非核心线程的大小也为无限大。适用于执行周期性的任务。</p>
<p>SingleThreadPool:只有一条线程来执行任务，适用于有顺序的任务的应用场景。</p>
<p>FixedThreadPool:定长的线程池，有核心线程，核心线程的即为最大的线程数量，没有非核心线程</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/25/Java%E4%B8%AD%E7%9A%84RPC/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3/" rel="next" title="操作系统与计网相关">
      操作系统与计网相关 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#title-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-number">1.</span> <span class="nav-text">title:多线程知识点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.1.</span> <span class="nav-text">volatile关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM"><span class="nav-number">2.1.1.</span> <span class="nav-text">Java的内存模型(JMM)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile%E7%89%B9%E6%80%A7"><span class="nav-number">2.1.2.</span> <span class="nav-text">volatile特性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8%E5%8F%8C%E9%87%8D%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E4%BD%9C%E7%94%A8"><span class="nav-number">2.2.</span> <span class="nav-text">volatile关键字在双重锁实现单例作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.饿汉式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%87%92%E6%B1%89%E5%BC%8F"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.懒汉式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%91%A2"><span class="nav-number">2.2.3.</span> <span class="nav-text">3.为什么是双重校验锁实现单例模式呢</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized"><span class="nav-number">2.3.</span> <span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep-%E5%92%8Cwait-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.4.</span> <span class="nav-text">sleep()和wait()的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sleep-%E6%96%B9%E6%B3%95"><span class="nav-number">2.4.1.</span> <span class="nav-text">sleep()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wait-%E6%96%B9%E6%B3%95"><span class="nav-number">2.4.2.</span> <span class="nav-text">wait()方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock-%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">2.5.</span> <span class="nav-text">ReentrantLock(重入锁)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentranLock%E5%92%8CSychroniezd%E7%9A%84%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="nav-number">2.5.1.</span> <span class="nav-text">ReentranLock和Sychroniezd的相同点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock%E7%9A%84%E9%A2%9D%E5%A4%96%E5%8A%9F%E8%83%BD"><span class="nav-number">2.5.2.</span> <span class="nav-text">ReentrantLock的额外功能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReadWriteLock-%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">2.6.</span> <span class="nav-text">ReadWriteLock(读写锁)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-number">2.6.1.</span> <span class="nav-text">特性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS%E6%9C%BA%E5%88%B6"><span class="nav-number">2.7.</span> <span class="nav-text">CAS机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">2.7.1.</span> <span class="nav-text">CAS的缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronize%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">2.8.</span> <span class="nav-text">synchronize的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%88%E8%87%AA%E9%80%82%E5%BA%94%E9%94%81%EF%BC%89"><span class="nav-number">2.8.1.</span> <span class="nav-text">自旋锁（自适应锁）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="nav-number">2.8.2.</span> <span class="nav-text">锁消除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">2.8.3.</span> <span class="nav-text">重量级锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">2.8.4.</span> <span class="nav-text">轻量级锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">2.8.5.</span> <span class="nav-text">偏向锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS"><span class="nav-number">2.9.</span> <span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6"><span class="nav-number">2.9.1.</span> <span class="nav-text">框架</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.10.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">2.10.1.</span> <span class="nav-text">线程池的优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%8F%82%E6%95%B0"><span class="nav-number">2.10.2.</span> <span class="nav-text">线程池的创建与参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">2.10.3.</span> <span class="nav-text">线程池的流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.10.4.</span> <span class="nav-text">四种常见线程池</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zyh</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zyh</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
